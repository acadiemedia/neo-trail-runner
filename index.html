<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neo Trail Runner</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@latest/dist/togeojson.js"></script>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #mapid { height: 100vh; width: 100vw; position: absolute; top: 0; left: 0; z-index: 0; }
    #canvas { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
    #timeline { position: absolute; bottom: 10px; left: 10px; width: 300px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; z-index: 2; }
    .snapshot-item { margin-bottom: 5px; }
    .visited-path { stroke: blue !important; }
    .important-path { stroke: yellow !important; stroke-width: 4px !important; }
    #controls { position: absolute; top: 10px; right: 10px; z-index: 2; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; }
    #file-input { margin-top: 10px; }
    #video-overlay { position: absolute; top: 10px; left: 10px; width: 200px; height: 150px; background: rgba(0,0,0,0.5); color: white; display: flex; justify-content: center; align-items: center; z-index: 2; border-radius: 5px; }
  </style>
</head>
<body>
  <div id="mapid"></div>
  <canvas id="canvas"></canvas>
  <div id="timeline">
    <h3>Snapshots</h3>
    <div id="snapshot-list"></div>
  </div>
  <div id="controls">
    <button id="set-home-button">Set Home</button>
    <button id="start-recording-button">Start Recording</button>
    <button id="stop-recording-button">Stop Recording</button>
    <button id="play-back-button">Play Back</button>
    <input type="file" id="file-input" accept=".gpx,.kml" />
  </div>
  <div id="video-overlay">Video Feed with AI Visuals (Coming Soon)</div>

  <script>
    const map = L.map('mapid').setView([47.5615, -52.7126], 13); // St. John's, Newfoundland
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let snapshots = []; // For manually placed pins
    let markers = []; // For manually placed pins
    let homeBase = null;
    let homeBaseMarker = null;
    let lastVisitedSnapshot = null;

    let isRecording = false;
    let recordedTrailPoints = []; // Points collected during recording
    let recordedTrails = []; // Stored recorded trails
    let recordingStartTime = null;

    document.getElementById('set-home-button').onclick = () => {
      const center = map.getCenter();
      homeBase = { lat: center.lat, lng: center.lng };
      if (homeBaseMarker) {
        map.removeLayer(homeBaseMarker);
      }
      homeBaseMarker = L.marker([homeBase.lat, homeBase.lng], { icon: L.divIcon({ className: 'home-icon', html: 'üè†' }) }).addTo(map)
        .bindPopup(`<b>Home Base</b><br>${homeBase.lat.toFixed(4)}, ${homeBase.lng.toFixed(4)}`);
      drawConnections();
    };

    document.getElementById('start-recording-button').onclick = () => {
      isRecording = true;
      recordedTrailPoints = [];
      recordingStartTime = new Date();
      console.log('Recording started');
    };

    document.getElementById('stop-recording-button').onclick = () => {
      isRecording = false;
      if (recordedTrailPoints.length > 1) {
        const recordingEndTime = new Date();
        const duration = (recordingEndTime - recordingStartTime) / 1000; // in seconds
        const distance = calculateDistance(recordedTrailPoints); // Haversine formula
        recordedTrails.push({ trail: recordedTrailPoints, duration: duration, distance: distance, id: recordedTrails.length + 1 });
        console.log('Recording stopped. Trail saved.', recordedTrails);
        updateTimeline();
      }
    };

    document.getElementById('play-back-button').onclick = () => {
      if (recordedTrails.length > 0) {
        const trailToPlay = recordedTrails[recordedTrails.length - 1].trail; // Play the last recorded trail
        playBackTrail(trailToPlay);
      }
    };

    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        const text = event.target.result;
        let geojson;
        if (file.name.endsWith('.gpx')) {
          geojson = togeojson.gpx(new DOMParser().parseFromString(text, 'text/xml'));
        } else if (file.name.endsWith('.kml')) {
          geojson = togeojson.kml(new DOMParser().parseFromString(text, 'text/xml'));
        }

        if (geojson) {
          L.geoJSON(geojson, { style: { color: 'purple', weight: 3 } }).addTo(map);
          // Optionally, fit map to bounds of loaded track
          map.fitBounds(L.geoJSON(geojson).getBounds());
        }
      };
      reader.readAsText(file);
    });

    map.on('click', function(e) {
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;

      if (isRecording) {
        recordedTrailPoints.push({ lat: lat, lng: lng, timestamp: new Date() });
        console.log('Recorded point:', lat, lng);
        drawConnections(); // Redraw to show the green recording line
      } else {
        // Manual pin creation (existing functionality)
        const snapshot = {
          id: snapshots.length + 1,
          lat: lat,
          lng: lng,
          timestamp: new Date().toLocaleString(),
          description: `Snapshot at ${lat.toFixed(4)}, ${lng.toFixed(4)}`,
          visited: false
        };
        snapshots.push(snapshot);

        const marker = L.marker([lat, lng]).addTo(map)
          .bindPopup(`<b>Snapshot ${snapshot.id}</b><br>${snapshot.description}<br><button onclick="visitSnapshot(${snapshot.id})">Visit</button>`);
        markers.push(marker);

        updateTimeline();
        drawConnections();
      }
    });

    function visitSnapshot(id) {
      const snapshot = snapshots.find(s => s.id === id);
      if (snapshot) {
        snapshot.visited = true;
        lastVisitedSnapshot = snapshot;
        updateTimeline();
        drawConnections(); // Redraw all connections to update colors
      }
    }

    function updateTimeline() {
      const snapshotList = document.getElementById('snapshot-list');
      snapshotList.innerHTML = '';
      snapshots.forEach(s => {
        const div = document.createElement('div');
        div.className = 'snapshot-item';
        div.innerHTML = `<b>${s.id}.</b> ${s.description} (${s.timestamp}) ${s.visited ? '(Visited)' : ''}`;
        snapshotList.appendChild(div);
      });

      recordedTrails.forEach((trailData, index) => {
        const div = document.createElement('div');
        div.className = 'snapshot-item';
        div.innerHTML = `<b>Recorded Trail ${trailData.id}:</b> Distance: ${trailData.distance.toFixed(2)} km, Duration: ${trailData.duration.toFixed(0)} s <button onclick="playBackTrail(recordedTrails[${index}].trail)">Play</button>`;
        snapshotList.appendChild(div);
      });
    }

    async function getRoute(startLat, startLng, endLat, endLng) {
      const url = `https://router.project-osrm.org/route/v1/driving/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=geojson`;
      const response = await fetch(url);
      const data = await response.json();
      if (data.routes && data.routes.length > 0) {
        return data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]); // [lat, lng]
      } else {
        return [[startLat, startLng], [endLat, endLng]]; // Fallback to straight line
      }
    }

    async function drawConnections() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 2;

      // Draw connections from home base to all snapshots
      if (homeBase) {
        for (const s of snapshots) {
          const color = (s.visited && lastVisitedSnapshot && s.id === lastVisitedSnapshot.id) ? 'yellow' : (s.visited ? 'blue' : 'red');
          await drawSingleConnection(homeBase, s, color);
        }
      }

      // Draw connections between sequential snapshots
      for (let i = 0; i < snapshots.length - 1; i++) {
        const s1 = snapshots[i];
        const s2 = snapshots[i+1];
        const color = (s1.visited && s2.visited && lastVisitedSnapshot && (s1.id === lastVisitedSnapshot.id || s2.id === lastVisitedSnapshot.id)) ? 'yellow' : (s1.visited && s2.visited ? 'blue' : 'red');
        await drawSingleConnection(s1, s2, color);
      }

      // Draw recorded trails (green line during recording, or for stored trails)
      if (isRecording && recordedTrailPoints.length > 1) {
        for (let i = 0; i < recordedTrailPoints.length - 1; i++) {
          await drawSingleConnection(recordedTrailPoints[i], recordedTrailPoints[i+1], 'green'); // Recorded trails in green
        }
      }
      for (const trailData of recordedTrails) {
        const trail = trailData.trail;
        if (trail.length > 1) {
          for (let i = 0; i < trail.length - 1; i++) {
            await drawSingleConnection(trail[i], trail[i+1], 'green');
          }
        }
      }
    }

    async function drawSingleConnection(s1, s2, color) {
      const route = await getRoute(s1.lat, s1.lng, s2.lat, s2.lng);

      ctx.strokeStyle = color;
      ctx.beginPath();

      if (route.length > 0) {
        const startPoint = map.latLngToContainerPoint(route[0]);
        ctx.moveTo(startPoint.x, startPoint.y);
        for (let i = 1; i < route.length; i++) {
          const point = map.latLngToContainerPoint(route[i]);
          ctx.lineTo(point.x, point.y);
        }
      }
      ctx.stroke();
    }

    function calculateDistance(trail) {
      let totalDistance = 0;
      for (let i = 0; i < trail.length - 1; i++) {
        totalDistance += map.distance([trail[i].lat, trail[i].lng], [trail[i+1].lat, trail[i+1].lng]);
      }
      return totalDistance / 1000; // Convert to kilometers
    }

    let playbackMarker = null;
    let playbackInterval = null;
    let playbackMarkers = [];

    async function playBackTrail(trail) {
      if (playbackInterval) clearInterval(playbackInterval);
      if (playbackMarker) map.removeLayer(playbackMarker);
      playbackMarkers.forEach(m => map.removeLayer(m)); // Remove old playback markers
      playbackMarkers = [];

      // Add temporary markers for all points in the trail
      trail.forEach((point, index) => {
        const marker = L.marker([point.lat, point.lng]).addTo(map)
          .bindPopup(`<b>Trail Point ${index + 1}</b><br>${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}`);
        playbackMarkers.push(marker);
      });

      playbackMarker = L.marker([trail[0].lat, trail[0].lng]).addTo(map);
      let playbackIndex = 0;

      playbackInterval = setInterval(() => {
        if (playbackIndex < trail.length - 1) {
          playbackIndex++;
          playbackMarker.setLatLng([trail[playbackIndex].lat, trail[playbackIndex].lng]);
          map.panTo([trail[playbackIndex].lat, trail[playbackIndex].lng]);
        } else {
          clearInterval(playbackInterval);
          map.removeLayer(playbackMarker);
          playbackMarker = null;
          playbackMarkers.forEach(m => map.removeLayer(m)); // Remove temporary markers
          playbackMarkers = [];
        }
      }, 200); // Adjust playback speed here
    }

    // Fetch EV stations
    fetch('https://api.openchargemap.io/v3/poi/?output=json&countrycode=CA&maxresults=100&compact=true&verbose=false&latitude=47.5615&longitude=-52.7126&distance=50')
      .then(response => response.json())
      .then(data => {
        data.forEach(station => {
          if (station.AddressInfo && station.AddressInfo.Latitude && station.AddressInfo.Longitude) {
            L.marker([station.AddressInfo.Latitude, station.AddressInfo.Longitude], { icon: L.divIcon({ className: 'ev-icon', html: '‚ö°' }) }).addTo(map)
              .bindPopup(`<b>${station.AddressInfo.Title}</b><br>${station.AddressInfo.AddressLine1 || ''}`);
          }
        });
      })
      .catch(error => console.error('Error fetching EV stations:', error));

    map.on('moveend', drawConnections);
    window.onresize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawConnections();
    };
  </script>
</body>
</html>